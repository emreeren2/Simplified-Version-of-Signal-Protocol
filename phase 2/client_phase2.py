# -*- coding: utf-8 -*-
"""Client_phase2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ar-6PzX9EQy1mfL22EW0kiUvzXXmXxjN
"""

import math
import time
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve,Point
from Crypto.Hash import SHA3_256, HMAC, SHA256
import requests
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
import random
import re
import json

E = Curve.get_curve('secp256k1')
n = E.order
p = E.field
P = E.generator
a = E.a
b = E.b
print("Base point:\n", P)
print("p :", p)
print("a :", a)
print("b :", b)
print("n :", n)

API_URL = 'http://10.92.52.175:5000/'

stuID =  25139  ## Change this to your ID number

#server's Identitiy public key
IKey_Ser = Point(93223115898197558905062012489877327981787036929201444813217704012422483432813 , 8985629203225767185464920094198364255740987346743912071843303975587695337619, E)

#Send Public Identitiy Key Coordinates and corresponding signature
def IKRegReq(h,s,x,y):
    mes = {'ID':stuID, 'H': h, 'S': s, 'IKPUB.X': x, 'IKPUB.Y': y}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "IKRegReq"), json = mes)		
    if((response.ok) == False): print(response.json())

#Send the verification code
def IKRegVerify(code):
    mes = {'ID':stuID, 'CODE': code}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "IKRegVerif"), json = mes)
    if((response.ok) == False): raise Exception(response.json())
    print(response.json())

#Send SPK Coordinates and corresponding signature
def SPKReg(h,s,x,y):
    mes = {'ID':stuID, 'H': h, 'S': s, 'SPKPUB.X': x, 'SPKPUB.Y': y}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "SPKReg"), json = mes)		
    if((response.ok) == False): 
        print(response.json())
    else: 
        res = response.json()
        return res['SPKPUB.X'], res['SPKPUB.Y'], res['H'], res['S']

#Send OTK Coordinates and corresponding hmac
def OTKReg(keyID,x,y,hmac):
    mes = {'ID':stuID, 'KEYID': keyID, 'OTKI.X': x, 'OTKI.Y': y, 'HMACI': hmac}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "OTKReg"), json = mes)		
    print(response.json())
    if((response.ok) == False): return False
    else: return True

#Send the reset code to delete your Identitiy Key
#Reset Code is sent when you first registered
def ResetIK(rcode):
    mes = {'ID':stuID, 'RCODE': rcode}
    print("Sending message is: ", mes)
    response = requests.delete('{}/{}'.format(API_URL, "ResetIK"), json = mes)		
    print(response.json())
    if((response.ok) == False): return False
    else: return True

#Sign your ID  number and send the signature to delete your SPK
def ResetSPK(h,s):
    mes = {'ID':stuID, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.delete('{}/{}'.format(API_URL, "ResetSPK"), json = mes)		
    print(response.json())
    if((response.ok) == False): return False
    else: return True

#Send the reset code to delete your Identitiy Key
def ResetOTK(h,s):
    mes = {'ID':stuID, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.delete('{}/{}'.format(API_URL, "ResetOTK"), json = mes)		
    if((response.ok) == False): print(response.json())

#Pseudo-client will send you 5 messages to your inbox via server when you call this function
def PseudoSendMsg(h,s):
    mes = {'ID':stuID, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "PseudoSendMsg"), json = mes)		
    print(response.json())

#get your messages. server will send 1 message from your inbox 
def ReqMsg(h,s):
    mes = {'ID':stuID, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.get('{}/{}'.format(API_URL, "ReqMsg"), json = mes)	
    print(response.json())	
    if((response.ok) == True): 
        res = response.json()
        return res["IDB"], res["OTKID"], res["MSGID"], res["MSG"], res["EK.X"], res["EK.Y"]

#If you decrypted the message, send back the plaintext for grading
def Checker(stuID, stuIDB, msgID, decmsg):
    mes = {'IDA':stuID, 'IDB':stuIDB, 'MSGID': msgID, 'DECMSG': decmsg}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "Checker"), json = mes)		
    print(response.json())

# IK data
sA = 75365099691681163466259435055151388598990196366045037773536006665067396329561
Q_x = 87058090705547232336742506266448902457032608537577399368869745072849975094263
Q_y = 73863361865121729253370141189521784002483174318560123943873444021233722393171

s_ik = 38435919104545028465405229083851199426577612833328471419512121279897034838259
h_ik = 40139398399024429188254655216662123008175195428486006903289784284292094948763

# SPK data
spk_private = 49760804016305672242628858452671561631883295017037579045439043666340119331411
spk_pub_x = 13279412479756039023006939294151267045839717479408817839293710814463378950452
spk_pub_y = 93617390663867776116902322986952603938589221775532373175859757173961357675363

h_spk = 70079813329073930856804606363140448062677695844504871159148958480169809247078
s_spk = 42702578452500864554658062321887469197282606023250231586097905168842648683915

# OTK data
otk_private = [81661962775791531255393590218032810348611196057800092950972910673728483913293, 52808665550935137250118206376573576203141304345939680267257950392200540207015, 28886528209940086927211574720079351376569346129303597582466848064924258131196, 11114466964466141026367702073664155613887604275985718533928007399121172719121, 17166357728138738026932544999677587823688912721806684576840951659670965088038, 89828764614649288349946443494126545878918699713795459712736909795019648787538, 48168878674606644491705808962129225172098876787988203995044137678806445123558, 91179985255603002478337425498383773831413918717804015885447630247048388959701, 82924893139980026608916710627158509866282852529554964410349276866878225755082, 90870193415124165058039276172179735704530307717037153962822467285881689168350]

# Signing my stuID with my private IK in order to get messages from the server:
k = random.randint(1, n-2)
R = k * P
r = R.x % n

r_byte_array = r.to_bytes((r.bit_length() +7)//8, byteorder = 'big')
m_byte_array = stuID.to_bytes((stuID.bit_length() +7)//8, byteorder = 'big')
r_m = r_byte_array + m_byte_array #concatenation of r and m where m is stuID

h = SHA3_256.new(r_m)
h = int.from_bytes(h.digest(), byteorder='big') % n

s = (k - (sA * h)) % n
print("s:", s)
print("h:", h)

PseudoSendMsg(h,s)

# requesting messages from the server:
otkID_array = []
msgID_array = []
msg_array = []
for i in range(5):
    stuIDB, otkID, msgID, msg, ek_x, ek_y = ReqMsg(h,s)
    msg_array.append(msg)
    otkID_array.append(otkID)
    msgID_array.append(msgID)

first_iteration = True
counter = 0
for message in msg_array:
    message_byte_array = message.to_bytes((message.bit_length() +7)//8, byteorder = 'big')
    
    # hmac of the message
    message_HMAC = message_byte_array[len(message_byte_array)-32:]
    #print(message_HMAC) 

    # nonce and the ciphertext
    message_with_nonce = message_byte_array[:len(message_byte_array)-32]
    #print(message_with_nonce)

    # ciphertext
    ciphertext = message_byte_array[8:len(message_byte_array)-32]
    #print(ciphertext)


    # _session key generation start_
    EK_B_point = Point(ek_x, ek_y, curve = E)
    T = otk_private[otkID] * EK_B_point
    T_x = T.x
    T_y = T.y

    T_x_byte_array = T_x.to_bytes((T_x.bit_length() +7)//8, byteorder = 'big')
    T_y_byte_array = T_y.to_bytes((T_y.bit_length() +7)//8, byteorder = 'big')
    U = T_x_byte_array + T_y_byte_array + b'MadMadWorld'

    K_S = SHA3_256.new(U)
    # _session key generation end_

    # _key derivation start_
    if(first_iteration):
        K_KDF = K_S
        first_iteration = False
    else:
        K_KDF = SHA3_256.new(K_HMAC.digest() + b'YouWillNotHaveTheDrink')

    K_ENC = SHA3_256.new(K_KDF.digest() + b'LeaveMeAlone')
    K_HMAC = SHA3_256.new(K_ENC.digest() + b'GlovesAndSteeringWheel')
    # _key derivation end_

    # obtaining hmac from ciphertext
    hmac = HMAC.new(K_HMAC.digest(), ciphertext, digestmod=SHA256)
    hmac = hmac.digest()

    # checking MAC values
    if(hmac == message_HMAC):
        print("HMAC is verified")

        # dencryption of the message
        cipher = AES.new(K_ENC.digest(), AES.MODE_CTR, nonce = message_with_nonce[0:8])
        dtext = cipher.decrypt(message_with_nonce[8:])
        decrypted_message = dtext.decode('utf-8')

        print("Decrypted message:", decrypted_message)

        # cheking decrypted message
        Checker(stuID, stuIDB, msgID_array[counter], decrypted_message)
    else: 
        print("HMAC is not verified")
        Checker(stuID, stuIDB, msgID_array[counter], 'INVALIDHMAC')

    counter = counter + 1


    print("_________________________________")

