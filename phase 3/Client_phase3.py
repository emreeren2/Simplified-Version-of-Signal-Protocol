# -*- coding: utf-8 -*-
"""Client.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jos-GLC2FcjZ2wQADVzSzV7NveJb3rFI
"""

pip install ecpy

pip install pycryptodome

pip install sympy

pip install requests

import math
import time
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve,Point
from Crypto.Hash import SHA3_256, HMAC, SHA256
import requests
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
import random
import re
import json

from random import randint, seed
from ecpy.curves import Curve
from Crypto.Hash import SHA3_256
from Crypto import Random   # a bit better secure random number generation 
import math

E = Curve.get_curve('secp256k1')
n = E.order
p = E.field
P = E.generator
a = E.a
b = E.b
print("Base point:\n", P)
print("p :", p)
print("a :", a)
print("b :", b)
print("n :", n)

k = Random.new().read(int(math.log(n,2)))
k = int.from_bytes(k, byteorder='big')%n

Q = k*P
print("\nQ:\n", Q)
print("Q on curve?", E.is_on_curve(Q))

import math
import time
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve,Point
from Crypto.Hash import SHA3_256, HMAC, SHA256
import requests
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
import random
import re
import json

API_URL = 'http://10.92.52.175:5000/'

stuID =  25139  # id of emre
stuID_ = 26846  # id of ekin
pseudo_cliend_ID = 18007 # id of the server


#server's Identitiy public key
IKey_Ser = Point(93223115898197558905062012489877327981787036929201444813217704012422483432813 , 8985629203225767185464920094198364255740987346743912071843303975587695337619, E)

def IKRegReq(h,s,x,y):
    mes = {'ID':stuID, 'H': h, 'S': s, 'IKPUB.X': x, 'IKPUB.Y': y}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "IKRegReq"), json = mes)		
    if((response.ok) == False): print(response.json())

def IKRegVerify(code):
    mes = {'ID':stuID, 'CODE': code}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "IKRegVerif"), json = mes)
    if((response.ok) == False): raise Exception(response.json())
    print(response.json())

def SPKReg(h,s,x,y):
    mes = {'ID':stuID, 'H': h, 'S': s, 'SPKPUB.X': x, 'SPKPUB.Y': y}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "SPKReg"), json = mes)		
    if((response.ok) == False): 
        print(response.json())
    else: 
        res = response.json()
        return res['SPKPUB.X'], res['SPKPUB.Y'], res['H'], res['S']

def OTKReg(id, keyID,x,y,hmac):
    mes = {'ID':id, 'KEYID': keyID, 'OTKI.X': x, 'OTKI.Y': y, 'HMACI': hmac}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "OTKReg"), json = mes)		
    print(response.json())
    if((response.ok) == False): return False
    else: return True


def ResetIK(rcode):
    mes = {'ID':stuID, 'RCODE': rcode}
    print("Sending message is: ", mes)
    response = requests.delete('{}/{}'.format(API_URL, "ResetIK"), json = mes)		
    print(response.json())
    if((response.ok) == False): return False
    else: return True

def ResetSPK(h,s):
    mes = {'ID':stuID, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.delete('{}/{}'.format(API_URL, "ResetSPK"), json = mes)		
    print(response.json())
    if((response.ok) == False): return False
    else: return True

def ResetOTK(id, h,s):
    mes = {'ID':id, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.delete('{}/{}'.format(API_URL, "ResetOTK"), json = mes)		
    print(response.json())

def PseudoSendMsgPH3(h,s):
    mes = {'ID':stuID, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "PseudoSendMsgPH3"), json = mes)		
    print(response.json())

def ReqMsg(id, h,s):
    mes = {'ID':id, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.get('{}/{}'.format(API_URL, "ReqMsg"), json = mes)	
    print(response.json())	
    if((response.ok) == True): 
        res = response.json()
        return res["IDB"], res["OTKID"], res["MSGID"], res["MSG"], res["EK.X"], res["EK.Y"]
    
def SendMsg(idA, idB, otkid, msgid, msg, ekx, eky):
    mes = {"IDA":idA, "IDB":idB, "OTKID": int(otkid), "MSGID": msgid, "MSG": msg, "EK.X": ekx, "EK.Y": eky}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "SendMSG"), json = mes)
    print(response.json())    
        
def reqOTKB(stuID, stuIDB, h, s):
    OTK_request_msg = {'IDA': stuID, 'IDB':stuIDB, 'S': s, 'H': h}
    print("Requesting party B's OTK ...")
    response = requests.get('{}/{}'.format(API_URL, "ReqOTK"), json = OTK_request_msg)
    print(response.json()) 
    if((response.ok) == True):
        print(response.json()) 
        res = response.json()
        return res['KEYID'], res['OTK.X'], res['OTK.Y']      
    else:
        return -1, 0, 0

def Status(stuID, h, s):
    mes = {'ID':stuID, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.get('{}/{}'.format(API_URL, "Status"), json = mes)	
    print(response.json())
    if (response.ok == True):
        res = response.json()
        return res['numMSG'], res['numOTK'], res['StatusMSG']

# IK data
sA = 75365099691681163466259435055151388598990196366045037773536006665067396329561
Q_x = 87058090705547232336742506266448902457032608537577399368869745072849975094263
Q_y = 73863361865121729253370141189521784002483174318560123943873444021233722393171

s_ik = 38435919104545028465405229083851199426577612833328471419512121279897034838259
h_ik = 40139398399024429188254655216662123008175195428486006903289784284292094948763

# SPK data
spk_private = 49760804016305672242628858452671561631883295017037579045439043666340119331411
spk_pub_x = 13279412479756039023006939294151267045839717479408817839293710814463378950452
spk_pub_y = 93617390663867776116902322986952603938589221775532373175859757173961357675363

h_spk = 70079813329073930856804606363140448062677695844504871159148958480169809247078
s_spk = 42702578452500864554658062321887469197282606023250231586097905168842648683915

# OTK data
otk_private = [82643481877244209249664745771237418234477690096430811959717657855485886045638, 41174952876732969873061234384234992214813764471036650196683240643681961363261, 5583145587846578787702511470815367992841936970155580384792772696588865599734, 10972659824334756040423367058252295538222729497376669524883637366213216276543, 24476832630378983018284218279520822890885956931179901813178437213634407485252, 97006687499945984175088601268948450846237282033793682470458998922800746644169, 74160389491792105526360889492360032639008866468092295253480592634938957625351, 2064776794757669561866729584104676040173421819183532961139782611452732109747, 58659695490434911403509798003920364225859338325533233728677532945968361081857, 19148444294741063747898074518353049744162854913178507691342149982373162093145]

def regenerationOTK():
    #numMsg, numOTK, StatusMsg = Status(stuID, h_ik, s_ik)
    #needed_OTK = 10 - numOTK
    #print(needed_OTK, "number of OTKs is needed.")
    ResetOTK(stuID, h_ik, s_ik)
    
    # OTKs generation
    hmac_array = [] 
    OTK_public = []
    OTK_private = []
    K_HMAC = b'\xc9\xc4\xb5\xb7|\xab8h:\x90\xc7\xcaf\xb5T\xe8\xffg\x1cSL\xb3NS\xc1\x18~-z\xbc\\"'

    for i in range(10): #needed_OTK
        print("for ID:", i)
        otk_private = random.randint(1, n-2) # random secret key
        otk_pub = otk_private * P # generating public key

        otk_pub_x = otk_pub.x
        otk_pub_y = otk_pub.y

        print("private:", otk_private)
        print("public:", otk_pub)
        print("public_x:", otk_pub_x)
        print("public_y:", otk_pub_y)

        otk_pub_x_byte_array = otk_pub_x.to_bytes((otk_pub_x.bit_length() +7)//8, byteorder = 'big')
        otk_pub_y_byte_array = otk_pub_y.to_bytes((otk_pub_y.bit_length() +7)//8, byteorder = 'big')
        otk_public_x_y = otk_pub_x_byte_array + otk_pub_y_byte_array #concatenation of x and y 

        hmac = HMAC.new(key = K_HMAC, msg = otk_public_x_y, digestmod = SHA256)
        
        print("hmac.hexdigest():", hmac.hexdigest())
        hmac_array.append(hmac)
        OTK_public.append(otk_pub)
        OTK_private.append(otk_private)

        OTKReg(stuID, i, otk_pub_x, otk_pub_y, hmac.hexdigest())
        print('------------------------------------------')
    return OTK_private

otk_private = regenerationOTK() # updating Emre's private OTKs

numMsg, numOTK, StatusMsg = Status(stuID, h_ik, s_ik)

PseudoSendMsgPH3(h_ik, s_ik)

# Requesting messages from the server:
otkID_array = []
msgID_array = []
msg_array = []
for i in range(5):
    stuIDB, otkID, msgID, msg, ek_x, ek_y = ReqMsg(stuID, h_ik, s_ik)
    msg_array.append(msg)
    otkID_array.append(otkID)
    msgID_array.append(msgID)

# Getting messages from the Server:

first_iteration = True
decrypted_messages = []
counter = 0
for message in msg_array:
    message_byte_array = message.to_bytes((message.bit_length() +7)//8, byteorder = 'big')
    
    # hmac of the message
    message_HMAC = message_byte_array[len(message_byte_array)-32:]
    #print(message_HMAC) 

    # nonce and the ciphertext
    message_with_nonce = message_byte_array[:len(message_byte_array)-32]
    #print(message_with_nonce)

    # ciphertext
    ciphertext = message_byte_array[8:len(message_byte_array)-32]
    #print(ciphertext)


    # _session key generation start_
    EK_B_point = Point(ek_x, ek_y, curve = E)
    T = otk_private[otkID] * EK_B_point
    T_x = T.x
    T_y = T.y

    T_x_byte_array = T_x.to_bytes((T_x.bit_length() +7)//8, byteorder = 'big')
    T_y_byte_array = T_y.to_bytes((T_y.bit_length() +7)//8, byteorder = 'big')
    U = T_x_byte_array + T_y_byte_array + b'MadMadWorld'

    K_S = SHA3_256.new(U)
    # _session key generation end_

    # _key derivation start_
    if(first_iteration):
        K_KDF = K_S
        first_iteration = False
    else:
        K_KDF = SHA3_256.new(K_HMAC.digest() + b'YouWillNotHaveTheDrink')

    K_ENC = SHA3_256.new(K_KDF.digest() + b'LeaveMeAlone')
    K_HMAC = SHA3_256.new(K_ENC.digest() + b'GlovesAndSteeringWheel')
    # _key derivation end_

    # obtaining hmac from ciphertext
    hmac = HMAC.new(K_HMAC.digest(), ciphertext, digestmod=SHA256)
    hmac = hmac.digest()

    # checking MAC values
    if(hmac == message_HMAC):
        print("HMAC is verified")

        # dencryption of the message
        cipher = AES.new(K_ENC.digest(), AES.MODE_CTR, nonce = message_with_nonce[0:8])
        dtext = cipher.decrypt(message_with_nonce[8:])
        decrypted_message = dtext.decode('utf-8')

        print("Decrypted message:", decrypted_message)
        decrypted_messages.append(decrypted_message)

    else: 
        print("HMAC is not verified")


    counter = counter + 1


    print("_________________________________")

def signID(ID):
    k = random.randint(1, n-2)
    R = k * P
    r = R.x % n
    
    r_byte_array = r.to_bytes((r.bit_length() +7)//8, byteorder = 'big')
    m_byte_array = ID.to_bytes((ID.bit_length() +7)//8, byteorder = 'big')
    r_m = r_byte_array + m_byte_array #concatenation of r and m where m is ID

    h = SHA3_256.new(r_m)
    h = int.from_bytes(h.digest(), byteorder='big') % n

    s = (k - (sA * h)) % n
    return s, h

# Signing psuedo client ID then getting the OTK information:
def getRecieverOTK(reciever_id):
    s_c, h_c = signID(reciever_id)
    key_id_B, otk_x_B, otk_y_B   = reqOTKB(stuID, reciever_id, h_c, s_c)
    return key_id_B, otk_x_B, otk_y_B

# Encrypting and Sending messages which we got from the server, to the SERVER:
key_id_B, otk_x_B, otk_y_B = getRecieverOTK(pseudo_cliend_ID)

first_iteration = True
counter = 0
encrypted_messages = []

for message in decrypted_messages:
    
    message_byte_array = bytes(message, 'utf-8')
    #    _session key generation start_

    publicOTK_B_point = Point(otk_x_B, otk_y_B, curve = E)

    private_EK = otk_private[key_id_B % 10] #random.randint(1, n-2) #otk_private[key_id_B] # random secret key
    public_EK = private_EK * P  # generating public key

    T = private_EK * publicOTK_B_point
    T_x = T.x
    T_y = T.y

    T_x_byte_array = T_x.to_bytes((T_x.bit_length() +7)//8, byteorder = 'big')
    T_y_byte_array = T_y.to_bytes((T_y.bit_length() +7)//8, byteorder = 'big')
    U = T_x_byte_array + T_y_byte_array + b'MadMadWorld'

    K_S = SHA3_256.new(U)
    # _session key generation end_    

    # _key derivation start_
    if(first_iteration):
        K_KDF = K_S
        first_iteration = False
    else:
        K_KDF = SHA3_256.new(K_HMAC.digest() + b'YouWillNotHaveTheDrink')

    K_ENC = SHA3_256.new(K_KDF.digest() + b'LeaveMeAlone')
    K_HMAC = SHA3_256.new(K_ENC.digest() + b'GlovesAndSteeringWheel')
    # _key derivation end_

    
    cipher = AES.new(K_ENC.digest(), AES.MODE_CTR)
    message = cipher.encrypt(message_byte_array)

    hmac = HMAC.new(K_HMAC.digest(), message, digestmod=SHA256)
    hmac = hmac.digest()

    ctext = cipher.nonce + message + hmac
    ctext = int.from_bytes(ctext, byteorder='big')
    encrypted_messages.append(ctext)

    print(ctext)

    SendMsg(stuID, pseudo_cliend_ID, key_id_B, counter, ctext, public_EK.x, public_EK.y)

    counter = counter + 1

    print("_________________________________")

OTK_private_X = [] # private OTKs of Ekin
def resetReciever():
    # IK data (ekin)
    stuID = 26846
    sA = 26037317628054985808039282432726226222027022467068096985918786230345691957027
    Q_x = 34966638871069348443434840366429984004050324904300954986624560986102166574831
    Q_y = 18659130989987264139111259616350811871077628350857638087893010137535414968071

    s_ik = 10711401428822947968805605574831727095538167654217243597237904326250472141120
    h_ik = 2310173870477934111899724596823579375648537282076021725587322962459991319407

    # SPK data
    spk_private = 108276252172224876587334255735165101721975917778097283393900202750918785959710
    spk_pub_x = 97710353570137819193379937963704253670763857898842070763814037579480279837106
    spk_pub_y = 23341606178871725188404066641975812905580291605280961572149830211055662093589

    h_spk = 50104479202124469309008236680532873175969290556870197285989963025491089808550
    s_spk = 56354363435458804487927205429170920223354636346201640247065025929905617989041

    OTK_private = []

    ResetOTK(stuID, h_ik, s_ik)

    server_SPK_pub = (85040781858568445399879179922879835942032506645887434621361669108644661638219,
    46354559534391251764410704735456214670494836161052287022185178295305851364841,
    59007954485099251624961572416014350736776821380203722506041937308252698607740,
    101911760621645665479179352120241706761371492322672083429040706302642553897152)

    server_H = server_SPK_pub[2]
    server_S = server_SPK_pub[3]
    server_SPK_pub_x = server_SPK_pub[0]
    server_SPK_pub_y = server_SPK_pub[1]


    #Signature Verification:
    server_spk_pub_x_byte_array = server_SPK_pub_x.to_bytes((server_SPK_pub_x.bit_length() +7)//8, byteorder = 'big')
    server_spk_pub_y_byte_array = server_SPK_pub_y.to_bytes((server_SPK_pub_y.bit_length() +7)//8, byteorder = 'big')
    server_spk_x_y = server_spk_pub_x_byte_array + server_spk_pub_y_byte_array # concatenation of server_spk.x and server_spk.y 

    V = (server_S*P) + (server_H*IKey_Ser) 
    v = V.x % n
    v_byte_array = v.to_bytes((v.bit_length() +7)//8, byteorder = 'big')
    v_m = v_byte_array + server_spk_x_y
    h_ = SHA3_256.new(v_m)
    h_ = int.from_bytes(h_.digest(), byteorder='big') % n

    print("h_:", h_)
    print("h :", server_H)
    if(server_H == h_):
        print("verified")
    else:
        print("not verified")


    # Generating HMAC Key (KHMAC):
    server_SPK_pub_points = Point(server_SPK_pub_x, server_SPK_pub_y, curve = E)
    T = spk_private * server_SPK_pub_points
    T_x = T.x
    T_y = T.y

    T_x_byte_array = T_x.to_bytes((T_x.bit_length() +7)//8, byteorder = 'big')
    T_y_byte_array = T_y.to_bytes((T_y.bit_length() +7)//8, byteorder = 'big')
    joker = bytes("NoNeedToRideAndHide", 'utf-8')
    U = T_x_byte_array + T_y_byte_array + joker

    K_HMAC = SHA3_256.new(U)

    print("T_x_byte_array:", T_x_byte_array)
    print("T_y_byte_array:", T_y_byte_array)
    print("U:", U)
    print("K_HMAC:", K_HMAC.digest())
    
    # OTKs generation
    hmac_array = [] 
    OTK_public = []
    K_HMAC = K_HMAC.digest()

    for i in range(10): #needed_OTK
        print("for ID:", i)
        otk_private = random.randint(1, n-2) # random secret key
        otk_pub = otk_private * P # generating public key

        otk_pub_x = otk_pub.x
        otk_pub_y = otk_pub.y

        print("private:", otk_private)
        print("public:", otk_pub)
        print("public_x:", otk_pub_x)
        print("public_y:", otk_pub_y)

        otk_pub_x_byte_array = otk_pub_x.to_bytes((otk_pub_x.bit_length() +7)//8, byteorder = 'big')
        otk_pub_y_byte_array = otk_pub_y.to_bytes((otk_pub_y.bit_length() +7)//8, byteorder = 'big')
        otk_public_x_y = otk_pub_x_byte_array + otk_pub_y_byte_array #concatenation of x and y 

        hmac = HMAC.new(key = K_HMAC, msg = otk_public_x_y, digestmod = SHA256)
        
        print("hmac.hexdigest():", hmac.hexdigest())
        hmac_array.append(hmac)
        OTK_public.append(otk_pub)
        OTK_private_X.append(otk_private)

        OTKReg(stuID, i, otk_pub_x, otk_pub_y, hmac.hexdigest())
        print('------------------------------------------')

resetReciever()

# private OTKs of the Ekin
OTK_private_X

# Encrypting and Sending some messages to Ekin:
key_id_B, otk_x_B, otk_y_B = getRecieverOTK(stuID_) # recieving Ekin's OTK

first_iteration = True
counter = 0
encrypted_messages = []

#send_message = decrypted_messages
send_message = ["Merhaba Ekin", "Bakalim mesajlari alabilcen mi", "Naban", "kripto cok zevkli degil mi?", "Saygilar"]

for message in send_message:
    
    message_byte_array = bytes(message, 'utf-8')
    #    _session key generation start_

    publicOTK_B_point = Point(otk_x_B, otk_y_B, curve = E)

    private_EK = otk_private[key_id_B] #random.randint(1, n-2)#otk_private[key_id_B] # random secret key
    public_EK = private_EK * P  # generating public key

    T = private_EK * publicOTK_B_point
    T_x = T.x
    T_y = T.y

    T_x_byte_array = T_x.to_bytes((T_x.bit_length() +7)//8, byteorder = 'big')
    T_y_byte_array = T_y.to_bytes((T_y.bit_length() +7)//8, byteorder = 'big')
    U = T_x_byte_array + T_y_byte_array + b'MadMadWorld'

    K_S = SHA3_256.new(U)
    # _session key generation end_    

    # _key derivation start_
    if(first_iteration):
        K_KDF = K_S
        first_iteration = False
    else:
        K_KDF = SHA3_256.new(K_HMAC.digest() + b'YouWillNotHaveTheDrink')

    K_ENC = SHA3_256.new(K_KDF.digest() + b'LeaveMeAlone')
    K_HMAC = SHA3_256.new(K_ENC.digest() + b'GlovesAndSteeringWheel')
    # _key derivation end_

    
    cipher = AES.new(K_ENC.digest(), AES.MODE_CTR)
    message = cipher.encrypt(message_byte_array)

    hmac = HMAC.new(K_HMAC.digest(), message, digestmod=SHA256)
    hmac = hmac.digest()

    ctext = cipher.nonce + message + hmac
    ctext = int.from_bytes(ctext, byteorder='big')
    encrypted_messages.append(ctext)

    print(ctext)

    SendMsg(stuID, stuID_, key_id_B, counter, ctext, public_EK.x, public_EK.y)

    counter = counter + 1

    print("_________________________________")

# This function is for showing that Ekin can recieve messages from emre
def toShowRecieving():
# IK data (ekin)
    stuID = 26846
    sA = 26037317628054985808039282432726226222027022467068096985918786230345691957027
    s_ik = 10711401428822947968805605574831727095538167654217243597237904326250472141120
    h_ik = 2310173870477934111899724596823579375648537282076021725587322962459991319407

    print("_________________________________")
    print("_________________________________")
    print("Status:")
    Status(stuID, h_ik, s_ik)
    print("_________________________________")
    print("_________________________________")

    # Signing Ekin's stuID with Ekin's private IK in order to get messages from the server:
    k = random.randint(1, n-2)
    R = k * P
    r = R.x % n

    r_byte_array = r.to_bytes((r.bit_length() +7)//8, byteorder = 'big')
    m_byte_array = stuID.to_bytes((stuID.bit_length() +7)//8, byteorder = 'big')
    r_m = r_byte_array + m_byte_array #concatenation of r and m where m is stuID

    h = SHA3_256.new(r_m)
    h = int.from_bytes(h.digest(), byteorder='big') % n

    s = (k - (sA * h)) % n
    print("s:", s)
    print("h:", h)

    # requesting messages from the server:
    otkID_array = []
    msgID_array = []
    msg_array = []
    for i in range(5):
        stuIDB, otkID, msgID, msg, ek_x, ek_y = ReqMsg(stuID, h,s)
        msg_array.append(msg)
        otkID_array.append(otkID)
        msgID_array.append(msgID)

    print(otkID)
    print("_________________________________")
    print("_________________________________")

    first_iteration = True
    counter = 0
    for message in msg_array:
        message_byte_array = message.to_bytes((message.bit_length() +7)//8, byteorder = 'big')
        
        # hmac of the message
        message_HMAC = message_byte_array[len(message_byte_array)-32:]
        #print(message_HMAC) 

        # nonce and the ciphertext
        message_with_nonce = message_byte_array[:len(message_byte_array)-32]
        #print(message_with_nonce)

        # ciphertext
        ciphertext = message_byte_array[8:len(message_byte_array)-32]
        #print(ciphertext)

        # _session key generation start_
        EK_B_point = Point(ek_x, ek_y, curve = E)
        T = OTK_private_X[otkID % 10] * EK_B_point
        T_x = T.x
        T_y = T.y

        T_x_byte_array = T_x.to_bytes((T_x.bit_length() +7)//8, byteorder = 'big')
        T_y_byte_array = T_y.to_bytes((T_y.bit_length() +7)//8, byteorder = 'big')
        U = T_x_byte_array + T_y_byte_array + b'MadMadWorld'


        K_S = SHA3_256.new(U)
        # _session key generation end_

        # _key derivation start_
        if(first_iteration):
            K_KDF = K_S
            first_iteration = False
        else:
            K_KDF = SHA3_256.new(K_HMAC.digest() + b'YouWillNotHaveTheDrink')

        K_ENC = SHA3_256.new(K_KDF.digest() + b'LeaveMeAlone')
        K_HMAC = SHA3_256.new(K_ENC.digest() + b'GlovesAndSteeringWheel')
        # _key derivation end_



        # obtaining hmac from ciphertext
        hmac = HMAC.new(K_HMAC.digest(), ciphertext, digestmod=SHA256)
        hmac = hmac.digest()
        
        # checking MAC values
        if(hmac == message_HMAC):
            print("HMAC is verified")

            # dencryption of the message
            cipher = AES.new(K_ENC.digest(), AES.MODE_CTR, nonce = message_with_nonce[0:8])
            dtext = cipher.decrypt(ciphertext)
            decrypted_message = dtext.decode('utf-8')

            print("Decrypted message:", decrypted_message)

        else: 
            print("HMAC is not verified")

        counter = counter + 1


        print("_________________________________")


    print("_________________________________")
    Status(stuID, h_ik, s_ik)

toShowRecieving()

